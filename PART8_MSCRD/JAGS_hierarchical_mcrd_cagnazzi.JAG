
model{
  # recruitment process (technically, removal entry process)
  for(x in 1:n.sex){
    for(ti in 1:T){
      psi[ti,x] ~ dbeta(pr.psi[ti,x,1], pr.psi[ti,x,2])
    } # pp
  } # sex
  # all processes: mean, on logit
  llambda_mu ~ dnorm(pr.llambda_mu[1],pr.llambda_mu[2])
  lgte_mu ~ dnorm(pr.lgte_mu[1],pr.lgte_mu[2])
  lgaa_mu ~dnorm(pr.lgaa_mu[1],pr.lgaa_mu[2])
  lgbb_mu ~dnorm(pr.lgbb_mu[1],pr.lgbb_mu[2])
  lphi_mu ~dnorm(pr.lphi_mu[1],pr.lphi_mu[2])
  lp_mu ~dnorm(pr.lp_mu[1],pr.lp_mu[2])
  # all processes: hyper-prior: variance
  sig_p_all ~ dt(0,pr.sig_p_t[1], pr.sig_p_t[2]) T(0,1.5)
# priors on fixed effects
  # all processes: sex effects
  dlp_sex~dnorm(pr.dlp_sex[1],pr.dlp_sex[2])
  dlphi_sex~dnorm(pr.dlphi_sex[1],pr.dlphi_sex[2])
  # all processe: flooding effects [before]
  dlp_flo_dur ~ dnorm(pr.dlp_flo_dur[1],pr.dlp_flo_dur[2])
  # all processe: flooding effects [after]
  dlp_flo_aft ~ dnorm(pr.dlp_flo_aft[1],pr.dlp_flo_aft[2])
  # other strata effects on capture probability
  dlp_strata ~ dnorm(pr.dlp_strata[1],pr.dlp_strata[2])
  dlp_stratXflo ~ dnorm(pr.dlp_stratXflo[1],pr.dlp_stratXflo[2])
  # time effects on demographic processes 
  for(ti in 1:(T-1)){
      # reassemble on to the probability scale
      for(x in 1:n.sex){
        # model of assortment
        lambda[ti,x] <- 1/(1+exp(-llambda_mu ))
        # model of A->B
        gaa[ti,x] <- 1/(1+exp(-lgaa_mu )) # 
        # model of B->A
        gbb[ti,x] <- 1/(1+exp(-lgbb_mu )) # 
        # model of temporary emigration A->TE
        gate[ti,x] <- 1/(1+exp(-lgte_mu )) # -
        # model of temporary emigration B->TE
        gbte[ti,x] <- 1/(1+exp(-lgte_mu )) 
        # model on survival
        phi[ti,x] <- 1/(1+exp(-lphi_mu - dlphi_sex))
     } # time ti
  } # sex
  for(x in 1:n.sex){
     lambda[T,x] <- 1/(1+exp(-llambda_mu ))
  }
  # capture process
  for(k in 1:(E-1)){
     for(tti in 1:TTT.tot){
        dlp_t[tti,k] ~dnorm(0,pow(sig_p_all,-2))
        for(x in 1:n.sex){
          p[tti,k,x] <- PROP.AREA[tti,k]/(1+exp(-lp_mu - dlp_sex*equals(x,2) - dlp_strata*equals(k,2) - dlp_flo_dur*cov.p.flo[tti,k,1] - dlp_stratXflo*equals(k,2)*cov.p.flo[tti,k,1] - dlp_flo_aft*cov.p.flo[tti,k,2] - dlp_t[tti,k])) # hierarchical specification for all capture probabilities
        } # sex
     } # tii
  } # k
for(x in 1:n.sex){
  # first transition process: t0 to t1
  # states 1:A; 2:B; 3:TE; 4:non-recruitment; 5=dead
  tr[1,1,1,x] <- 1
  tr[2,1,1,x] <- 0
  tr[3,1,1,x] <- 0
  tr[4,1,1,x] <- 0
  tr[5,1,1,x] <- 0
  tr[6,1,1,x] <- 0
  tr[1,2,1,x] <- 0
  tr[2,2,1,x] <- 1
  tr[3,2,1,x] <- 0
  tr[4,2,1,x] <- 0
  tr[5,2,1,x] <- 0
  tr[6,2,1,x] <- 0
  tr[1,3,1,x] <- 0
  tr[2,3,1,x] <- 0
  tr[3,3,1,x] <- 1
  tr[4,3,1,x] <- 0
  tr[5,3,1,x] <- 0
  tr[6,3,1,x] <- 0
  tr[1,4,1,x] <- 0
  tr[2,4,1,x] <- 0
  tr[3,4,1,x] <- 1
  tr[4,4,1,x] <- 0
  tr[5,4,1,x] <- 0
  tr[6,4,1,x] <- 0
  tr[1,5,1,x] <- lambda[1,x]*psi[1,x] # recruit to A
  tr[2,5,1,x] <- (1-lambda[1,x])*psi[1,x] # recruit to B
  tr[3,5,1,x] <- 0 # TE latent states
  tr[4,5,1,x] <- 0 # TE latent states
  tr[5,5,1,x] <- 1-psi[1,x] # do not recruit
  tr[6,5,1,x] <- 0
  tr[1,6,1,x] <- 0
  tr[2,6,1,x] <- 0
  tr[3,6,1,x] <- 0
  tr[4,6,1,x] <- 0
  tr[5,6,1,x] <- 0
  tr[6,6,1,x] <- 0
  for(ti in 2:T){
    # the transition process: t to t+1
      tr[1,1,ti,x] <- (gaa[ti-1,x])*phi[ti-1,x]*(1-gate[ti-1,x]) # stays in A strata
      tr[2,1,ti,x] <- (1-gaa[ti-1,x])*phi[ti-1,x]*(1-gate[ti-1,x]) # goes to B strata
      tr[3,1,ti,x] <- gaa[ti-1,x]*gate[ti-1,x]*phi[ti-1,x] # goes to TE
      tr[4,1,ti,x] <- (1-gaa[ti-1,x])*gate[ti-1,x]*phi[ti-1,x] # goes to TE
      tr[5,1,ti,x] <- 0
      tr[6,1,ti,x] <- 1-phi[ti-1,x] # dies
      # from B strata to...
      tr[1,2,ti,x] <- (1-gbb[ti-1,x])*phi[ti-1,x]*(1-gbte[ti-1,x]) # goes to B strata
      tr[2,2,ti,x] <- (gbb[ti-1,x])*phi[ti-1,x]*(1-gbte[ti-1,x]) # stays in A strata
      tr[3,2,ti,x] <- (1-gbb[ti-1,x])*gbte[ti-1,x]*phi[ti-1,x] # A TE
      tr[4,2,ti,x] <- (gbb[ti-1,x])*gbte[ti-1,x]*phi[ti-1,x] # B TE
      tr[5,2,ti,x] <- 0
      tr[6,2,ti,x] <- 1-phi[ti-1,x] # dies
      # from TE-A to ...
      tr[1,3,ti,x] <- gaa[ti-1,x]*phi[ti-1,x]*(gate[ti-1,x]) # returns to A
      tr[2,3,ti,x] <- (1-gaa[ti-1,x])*phi[ti-1,x]*(gate[ti-1,x]) # return to B
      tr[3,3,ti,x] <- (1-gate[ti-1,x]) *phi[ti-1,x] # stays in TE
      tr[4,3,ti,x] <- 0
      tr[5,3,ti,x] <- 0
      tr[6,3,ti,x] <- 1-phi[ti-1,x] # dies
      # from TE-B to...
      tr[1,4,ti,x] <- (1-gbb[ti-1,x])*phi[ti-1,x]*(gbte[ti-1,x]) # back to A
      tr[2,4,ti,x] <- gbb[ti-1,x]*phi[ti-1,x]*(gbte[ti-1,x]) # back to B
      tr[3,4,ti,x] <- 0
      tr[4,4,ti,x] <- (1-gbte[ti-1,x])*phi[ti-1,x] # stays in TE-B
      tr[5,4,ti,x] <- 0
      tr[6,4,ti,x] <- 1-phi[ti-1,x] # dies
      # from recruitment to...
      tr[1,5,ti,x] <- lambda[ti,x]*psi[ti,x] # recruit to A
      tr[2,5,ti,x] <- (1-lambda[ti,x])*psi[ti,x] # recruit to B
      tr[3,5,ti,x] <- 0
      tr[4,5,ti,x] <- 0
      tr[5,5,ti,x] <- 1-psi[ti,x] # do not recruit
      tr[6,5,ti,x] <- 0
      tr[1,6,ti,x] <- 0
      tr[2,6,ti,x] <- 0
      tr[3,6,ti,x] <- 0
      tr[4,6,ti,x] <- 0 # 
      tr[5,6,ti,x] <- 0 # 
      tr[6,6,ti,x] <- 1 # stays dead
  } # done transition process
  # the emission process (capture process)
  for(tti in 1:TTT.tot){
      em[1,1,tti,x] <- p[tti,1,x]
      em[2,1,tti,x] <- 0
      em[3,1,tti,x] <- 1-p[tti,1,x]
      em[1,2,tti,x] <- 0
      em[2,2,tti,x] <- p[tti,2,x]
      em[3,2,tti,x] <- 1-p[tti,2,x]
      em[1,3,tti,x] <- 0
      em[2,3,tti,x] <- 0
      em[3,3,tti,x] <- 1 # te, unrecruited
      em[1,4,tti,x] <- 0
      em[2,4,tti,x] <- 0
      em[3,4,tti,x] <- 1 # te, unobservable
      em[1,5,tti,x] <- 0
      em[2,5,tti,x] <- 0
      em[3,5,tti,x] <- 1 # unrecruited, unobservable
      em[1,6,tti,x] <- 0
      em[2,6,tti,x] <- 0
      em[3,6,tti,x] <- 1 # dead, unobservable
  }
} # sex 
for(i in 1:M){
  # first primary period
  z[i,1] ~ dcat(tr[1:K,5,1,x.ind[i]]) # first primary period
  for(s in 1:T2[1]){ 
     y[i,s,1] ~ dcat(em[1:E, z[i,1], tt.ind[s,1], x.ind[i]])
  }
  # 2-T captures occassion
  for(ti in 2:T){
     z[i,ti] ~ dcat(tr[1:K,z[i,ti-1],ti,x.ind[i]]) # markov
     for(s in 1:T2[ti]){ 
        y[i,s,ti] ~ dcat(em[1:E, z[i,ti], tt.ind[s,ti], x.ind[i]])
     } # s
  } # ti primary periods
} # individuals M
# loglike: for WAIC estimation (conditional loglikelkhood, unfortunately)
for(i in 1:N.obs){
  for(ti in 1:T){
     for(s in 1:T2[ti]){ 
        llits[i,s,ti] <- logdensity.cat(y[i,s,ti], em[1:E, z[i,ti], tt.ind[s,ti], x.ind[i]])
     } # s
     llit[i,ti] <- sum(llits[i,1:T2[ti],ti])
  } # ti primary periods
  lli[i] <- sum(llit[i,1:T])
} # individuals N.obs
# POPULATION ABUNDANCE, RECRUITS, SUPER-POP
for(i in 1:M){
  for(x_ in 1:n.sex){
    alive_i[i,1,x_] <- step(4-z[i,1])*equals(x.ind[i],x_) # is animal alive or not  
    recruit_i[i,1,x_] <- alive_i[i,1,x_]*equals(x.ind[i],x_) # new recruit or
    for(k in 1:n.strata){
      N.onsite_i[i,1,k,x_]<-equals(z[i,1],k)*equals(x.ind[i],x_) # is on-site or not
    }
    for(ti in 2:T){
      alive_i[i,ti,x_] <- step(4-z[i,ti])*equals(x.ind[i],x_) # is animal alive or not
      recruit_i[i,ti,x_] <- alive_i[i,ti,x_]*equals(z[i,ti-1],5)*equals(x.ind[i],x_) # new recruit? 
      for(k in 1:n.strata){
        N.onsite_i[i,ti,k,x_]<-equals(z[i,ti],k)*equals(x.ind[i],x_) # is on site or not
      }
    }
  }
}
for(t_ in 1:T){
  for(x_ in 1:n.sex){ # loop through each sex
     for(k in 1:n.strata){
        N.onsite[t_,x_,k] <- sum(N.onsite_i[1:M,t_,k,x_])
     } # k
     alive[t_,x_] <- sum(alive_i[1:M,t_,x_])
     recruits[t_,x_] <- sum(recruit_i[1:M,t_,x_])
  } # x_
} # t_ 
}
